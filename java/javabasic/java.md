
### java语言特性

- java 默认采用 **Unicode** 编码格式,但是运行中根据系统而定

- **0x** 开头表示 **16进制** ，**0** 开头表示 **8进制**

- 这种形式表示的是 `char` 的二进制值，即该字符的编码值

  ```java
    char a = 0xffff;
  ```

- java的 `Random` 类的构造函数有两种，带种子和不带种子

    不带种子:   
    ```java
      java.uitl.Random random = new java.util.Random();
    ```
    这种方式返回的随机数，每次运行结果都不一样

    带种子：
    ```java
    java.util.Random random = new java.util.Random(10);
    ```
    这种方式生成的随机数，返回结果是固定的，**每次运行结果是固定的，生成的随机序列也是固定的，当种子不同，生成的随机序列则不同**

    在java中主要通过 `Math.random()` 方法和 `Random` 类获得随机数，这两种方式获取随机数的方式是相同的，通过查看 `Math.random()` 方法的代码可以知道，  `Math.random()` 也是通过生成一个 `Random` 的实例，然后调用 `nextDouble()` 方法获取随机数
    ```java
    public static double random() {
      return RandomNumberGeneratorHolder.randomNumberGenerator.nextDouble();
    }
    //randomNumberGenerator 为一个Random类实例

    private static final class RandomNumberGeneratorHolder {
      static final Random randomNumberGenerator = new Random();
    }

    ```

    在Java中，随机数的产生取决于种子，随机数和种子之间的关系遵循以下两个规则：
      1. 种子不同，产生不同的随机数。
      2. 种子相同，即使实例不同也产生相同的随机数。

  `Random`类的默认种子（无参构造）是`System.nanoTime()`的返回值（JDK1.5版本以前默认种子是`System.currentTimeMillis()`的返回值），这个值是距离某一个固定时间点的纳秒数，不同操作系统和硬件有不同的固定时间点，也就是不同的操作系统纳秒值是不同的，而同一操作系统的纳秒值也会不同，随机数自然也就不同了

  ```java
  //Random 无参构造函数
  public Random() {
    this(seedUniquifier() ^ System.nanoTime());
  }
  ```
#### 关于接口、抽象类、抽象类子类、实体类的关系

- 抽象类的注意问题

   1、抽象类不能被实例化，实例化的工作应该交由它的子类来完成，它只需要有一个引用即可

   2、抽象方法必须由子类来进行重写。

   3、只要包含一个抽象方法的抽象类，该方法必须要定义成抽象类，不管是否还包含有其他方法

   4、抽象类中可以包含具体的方法，当然也可以不包含抽象方法

   5、子类中的抽象方法不能与父类的抽象方法同名

   6、**`abstract`不能与`final`并列修饰同一个类**

   7、**`abstract` 不能与`private`、`static`、`final`或`native`并列修饰同一个方法**

- 关于接口的一些问题

    接口的所有方法的访问权限会被自动声明为`public`类型，为其他修饰符的时候会报错，一会接口要求其所有方法都是要被继承的类实现的

    实现接口的`非抽象类`必须实现该接口的所有方法，**`抽象类`** 则不用实现

- 抽象类是否可以继承实体类？----

    抽象类是可以继承实体类的，但是要求父类是可 **继承** 的，即父类不能是 **final** 类型的，并且要求父类父类有明确的构造函数，即 **子类抽象类能够访问到父类实体类的构造函数** ，即如果父类的构造函数被声明为 `private` 类型，则子类是无法访问的，就不能继承，如下边这种情况：

- 关于抽象类中的抽象方法是否必须在子类中实现的问题

    抽象类的抽象方法，在子类中可以选择实现，也可以选择不实现
    如果抽象类的抽象方法在子类中全部实现了，则这个类可以继续选择声明成抽象类，或者声明成实体类;如果抽象类的抽象方法在子类中没有被实现，那么这个方法如果被继承了，则继续使用`abstract`来修饰，也可以直接选择不继承，不管这个方法，知道该子类的子类或者递归子类来实现这些抽象方法；

- 关于继承的两个知识点
  - 所有的 **class** 都必须有一个 **constructor** ,即构造函数；如果你没有在代码里声明构造方法，则系统会自动给该类生成一个无参构造函数，但是 一旦你在类中声明了一个构造函数，不管是有参还是无参，系统都不会再为你提供那个无参构造函数了

  - 所有的子类 **(不管是实体类还是抽象类)** 构造函数都要求在第一行代码中调用父类的构造函数，如果子类构造函数没有调用父类构造函数，那么系统会默认调用父类的午餐构造函数，即`super();`；

- `finalize()` 为Object对象的方法，他的工作原理是：如果jvm垃圾回收器（gc）要准备回收一个对象，那么会先调用这个对象的`finalize`方法，并且在下一次垃圾回收动作发生时，才会真正回收对象占用的空间，这个方法相当于C++中的析构函数，`finalize`在三种情况下被调用：
  - 对象被GC回收时被调用，如`System.gc()`
  - 程序退出时为每一个对象调用一次`finalize`
  - 程序中显式调用

  对于java的gc而言，gc只回收内存资源，如果在对象中使用了非内存资源，比如文件和端口之类的非内存对象，那么就可以在`finalize`方法中定义回收

- java中子类和父类 **构造函数之间的关系** ：
    - 父类无构造函数或者有一个无参构造函数，子类若无构造函数或者有无参构造函数，子类构造函数中不需要显示的调用父类的构造函数，系统会自动在调用子类构造函数前调用父类的构造方法
    - **父类只有有参构造函数，子类在构造方法中必须显示调用父类的构造函数，否则编译报错**
    - 父类既有有参构造函数，也有无参构造函数，子类可以不再构造方法中调用父类的构造方法，此时子类调用的是父类的无参构造方法


- 对于 **静态变量** 和 **静态方法**，子类再调用时，调用的是父类的静态变量和静态方法，而不是继承自父类的静态方法和静态变量;但是如果子类中有同名的静态变量和静态方法，则调用的是子类本身的，因为子类的静态变量和静态方法会隐藏父类的;如果子类中没有定义同名的变量和方法，那么调用 "子类名.静态方法/变量"调用的是父类的方法及变量;如果子类中只定义了同名静态变量，而没有定义同名静态方法，则调用“子类名.静态方法”时，调用的是父类的静态方法，静态方法中的静态变量也是父类的;如果子类中既定义了与父类同名的静态变量，也定义了与父类同名的静态方法，这时候调用”子类名.静态方法"时，完全与父类无关，里面的静态变量也是子类的

-  **静态变量** 和 **静态方法** 是不能被覆写继承的，只能够被 **隐藏**，即子类拥有和父类相同的静态变量名或静态方法名，那么在子类中，就会隐藏父类相应的静态变量和静态方法

- `static`的局限性：1、 只能调用static变量 2、 只能调用static方法 3、 **不能以任何形式引用 `this`,`super`** 4、static 变量在定义时必须要进行初始化，且初始化时间要早于非静态变量

- 对于使用`final`的对象，（即引用数据类型），其引用地址是不能改变的，但是对象的内容是可以改变的

- `transient`关键字只能修饰变量，不能修饰方法和类;被`transient`关键字修饰的变量不能再被序列化，一个静态变量不管是否被`transient`变量修饰，都不能被序列化

- Java中，对象的序列化可以通过实现两种接口来实现，若实现的是Serializable接口，则所有的序列化将会自动进行，若实现的是Externalizable接口，则没有任何东西可以自动序列化，需要在writeExternal方法中进行手工指定所要序列化的变量，这与是否被transient修饰无关

- 在java中，所有的**类型转换**都是在运行时进行**正确性检查的**，这也是`RTTI`名字的含义：在运行时，识别一个对象的类型;

- 如果一个`static final`值是**"编译器常量"**，例如：
  ```java
  static final int staticFinal = 45;
  ```
  那么这个值不需要对该类进行初始化就可以读取;但是，如果只是将一个域设置为`static` 和 `final`的，还不足以确保这种行为，例如
  ```java
  static final int staticFinal = ClassInitialization.Random.nextInt(1000);
  ```
  如果一个`static`域不是`final`的，那么再对她访问时，总是要求在它被读取之前，先进行链接（为这个域分配存储空间）和初始化（初始化该存储空间）例如：
  ```java
  static int staticNonFinal = 9;
  ```
- 代理模式的关键就是封装修改  

### java内部类  
